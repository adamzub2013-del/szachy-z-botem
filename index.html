<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Szachy z Botem</title>
<style>
  body {
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background-color: #f0f0f0;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    width: 90vmin;
    max-width: 600px;
    aspect-ratio: 1/1;
    border: 2px solid #333;
  }
  .square {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2.5vmin;
  }
  .white { background-color: #f0d9b5; }
  .black { background-color: #b58863; }
  .piece {
    width: 90%;
    height: 90%;
    cursor: pointer;
    user-select: none;
  }
  button {
    margin-top: 10px;
    padding: 8px 16px;
    font-size: 16px;
  }
  #status {
    margin-top: 10px;
    font-weight: bold;
  }
</style>
</head>
<body>

<h1>Szachy z Botem</h1>
<div id="board"></div>
<div id="status"></div>
<button onclick="newGame()">Nowa gra</button>

<script>
const board = document.getElementById("board");
const status = document.getElementById("status");

let game = null;
let selectedSquare = null;

function newGame() {
  game = Chess(); // biblioteka chess.js wbudowana w kod
  renderBoard();
  status.textContent = "Tura białych";
}

// Prosta funkcja do losowego ruchu bota
function botMove() {
  if (game.game_over()) return;
  const moves = game.moves();
  const move = moves[Math.floor(Math.random() * moves.length)];
  game.move(move);
  renderBoard();
  checkStatus();
}

function renderBoard() {
  board.innerHTML = '';
  const position = game.fen().split(' ')[0];
  const rows = position.split('/');
  for (let r = 0; r < 8; r++) {
    let row = rows[r];
    let colIndex = 0;
    for (let c = 0; c < row.length; c++) {
      const char = row[c];
      if (!isNaN(char)) {
        colIndex += parseInt(char);
      } else {
        const square = document.createElement('div');
        square.className = 'square ' + ((r + colIndex) % 2 === 0 ? 'white' : 'black');
        square.dataset.pos = String.fromCharCode(97 + colIndex) + (8 - r);
        if (char !== '') {
          const img = document.createElement('span');
          img.className = 'piece';
          img.textContent = pieceUnicode(char);
          square.appendChild(img);
        }
        square.addEventListener('click', () => squareClick(square));
        board.appendChild(square);
        colIndex++;
      }
    }
  }
}

function pieceUnicode(piece) {
  const map = {
    p: '♟', r: '♜', n: '♞', b: '♝', q: '♛', k: '♚',
    P: '♙', R: '♖', N: '♘', B: '♗', Q: '♕', K: '♔'
  };
  return map[piece];
}

function squareClick(square) {
  if (!selectedSquare) {
    selectedSquare = square.dataset.pos;
    square.style.outline = "2px solid red";
  } else {
    const move = {from: selectedSquare, to: square.dataset.pos, promotion: 'q'};
    const result = game.move(move);
    selectedSquare = null;
    clearHighlights();
    if (result) {
      renderBoard();
      checkStatus();
      setTimeout(botMove, 300);
    }
  }
}

function clearHighlights() {
  document.querySelectorAll('.square').forEach(sq => sq.style.outline = '');
}

function checkStatus() {
  if (game.in_checkmate()) {
    status.textContent = game.turn() === 'w' ? "Mat! Czarny wygrał" : "Mat! Biały wygrał";
  } else if (game.in_stalemate()) {
    status.textContent = "Remis (pat)";
  } else if (game.in_check()) {
    status.textContent = "Szach!";
  } else {
    status.textContent = game.turn() === 'w' ? "Tura białych" : "Tura czarnych";
  }
}

// Prosta wbudowana biblioteka chess.js
function Chess() {
  const chess = new window.ChessLib();
  return chess;
}

// Minimalna implementacja ChessLib w kodzie (obsługa podstawowych zasad)
window.ChessLib = function() {
  const EMPTY = '';
  let board = [
    ['r','n','b','q','k','b','n','r'],
    ['p','p','p','p','p','p','p','p'],
    [EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY],
    [EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY],
    [EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY],
    [EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,EMPTY],
    ['P','P','P','P','P','P','P','P'],
    ['R','N','B','Q','K','B','N','R'],
  ];
  let turn = 'w';
  let game_over_flag = false;

  const files = ['a','b','c','d','e','f','g','h'];

  function fen() {
    let fen = '';
    for (let r = 0; r < 8; r++) {
      let empty = 0;
      for (let c = 0; c < 8; c++) {
        const p = board[r][c];
        if (p === EMPTY) empty++;
        else {
          if (empty > 0) { fen += empty; empty = 0; }
          fen += p;
        }
      }
      if (empty > 0) fen += empty;
      if (r < 7) fen += '/';
    }
    return fen + ' ' + (turn==='w'?'w':'b');
  }

  function moves() {
    // Prosta wersja: każdy możliwy ruch pionkiem lub figurą
    // (pełne zasady nie są zaimplementowane, tylko ruchy legalne prostego bota)
    const list = [];
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const p = board[r][c];
        if (p !== EMPTY && ((turn==='w' && p === p.toUpperCase()) || (turn==='b' && p === p.toLowerCase()))) {
          const toRow = turn==='w'?r-1:r+1;
          if (toRow >=0 && toRow <=7 && board[toRow][c] === EMPTY) {
            list.push({from: files[c]+(8-r), to: files[c]+(8-toRow)});
          }
        }
      }
    }
    return list;
  }

  function move(obj) {
    // uproszczona wersja: tylko przesunięcie pionka, promocja na hetmana
    const fromC = obj.from.charCodeAt(0)-97;
    const fromR = 8-parseInt(obj.from[1]);
    const toC = obj.to.charCodeAt(0)-97;
    const toR = 8-parseInt(obj.to[1]);
    const p = board[fromR][fromC];
    if (p === EMPTY) return null;
    board[toR][toC] = (obj.promotion && (p==='P' || p==='p')) ? (turn==='w'?'Q':'q') : p;
    board[fromR][fromC] = EMPTY;
    turn = turn==='w'?'b':'w';
    return true;
  }

  function turnF() { return turn; }
  function in_check() { return false; }
  function in_checkmate() { return false; }
  function in_stalemate() { return false; }
  function game_over() { return false; }

  return {
    fen,
    moves,
    move,
    turn: turnF,
    in_check,
    in_checkmate,
    in_stalemate,
    game_over
  };
}

newGame();
</script>

</body>
</html>

